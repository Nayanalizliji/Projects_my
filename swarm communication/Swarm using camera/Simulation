import cv2
import numpy as np
import math

# ArUco setup
aruco_dict = cv2.aruco.getPredefinedDictionary(cv2.aruco.DICT_4X4_50)
parameters = cv2.aruco.DetectorParameters()

# Camera
cap = cv2.VideoCapture(0)

# Simulated bot
bot_pos = np.array([100.0, 100.0])
bot_angle = 0
move_speed = 2.0
turn_speed = 5.0
target_pos = None

def get_angle(corners):
    p0 = corners[0][0]
    p1 = corners[0][1]
    dx = p1[0] - p0[0]
    dy = p1[1] - p0[1]
    angle = math.degrees(math.atan2(dy, dx))
    return (angle + 360) % 360

def angle_between(p1, p2):
    dx = p2[0] - p1[0]
    dy = p2[1] - p1[1]
    return (math.degrees(math.atan2(dy, dx)) + 360) % 360

def angle_diff(a, b):
    diff = (a - b + 180) % 360 - 180
    return diff

while True:
    ret, frame = cap.read()
    if not ret:
        break

    frame_height, frame_width = frame.shape[:2]

    # Detect markers
    detector = cv2.aruco.ArucoDetector(aruco_dict, parameters)
    corners, ids, _ = detector.detectMarkers(frame)

    target_pos = None
    if ids is not None:
        for i in range(len(ids)):
            id = ids[i][0]
            marker_corners = corners[i][0]
            cx = int(np.mean(marker_corners[:, 0]))
            cy = int(np.mean(marker_corners[:, 1]))
            angle = get_angle([marker_corners])

            if id == 2:
                target_pos = np.array([cx, cy])

            label = f"ID:{id} Pos:({cx},{cy}) Angle:{angle:.1f}Â°"
            cv2.putText(frame, label, (cx - 60, cy - 15),
                        cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 255), 2)
            cv2.polylines(frame, [np.int32(marker_corners)], True, (0, 255, 0), 2)
            cv2.circle(frame, (cx, cy), 5, (255, 0, 0), -1)

    # Movement logic
    if target_pos is not None:
        # Step 1: Calculate target angle
        target_angle = angle_between(bot_pos, target_pos)

        # Step 2: Turn bot toward the target
        diff = angle_diff(target_angle, bot_angle)
        if abs(diff) > 5:
            bot_angle = (bot_angle + turn_speed * np.sign(diff)) % 360
        else:
            # Step 3: Move forward
            distance = np.linalg.norm(bot_pos - target_pos)
            if distance > 10:
                rad = math.radians(bot_angle)
                bot_pos[0] += move_speed * math.cos(rad)
                bot_pos[1] += move_speed * math.sin(rad)

        # Draw line to target
        cv2.line(frame, tuple(bot_pos.astype(int)), tuple(target_pos.astype(int)), (0, 255, 255), 1)

    # Draw bot
    bot_int = tuple(np.int32(bot_pos))
    cv2.circle(frame, bot_int, 8, (255, 255, 0), -1)
    cv2.putText(frame, f"Bot Pos: {bot_int} Angle: {int(bot_angle)}", (10, frame_height - 10),
                cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 1)

    cv2.imshow("Simulated Swarm Bot", frame)
    if cv2.waitKey(30) == 27:
        break

cap.release()
cv2.destroyAllWindows()
